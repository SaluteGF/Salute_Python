<div align='center' >

# 数据类型

</div>

数据类型可以分为 **数字型** 和 **非数字型**

## 1. 数字型

> [程序练习](https://github.com/Nicolas-gaofeng/Salute_Python/blob/main/code/basic/data_type_python/data_type_digital.py)

### 1.1 整型 (Integers)

我们定义一个人的年龄的时候 使用age = 18 来定义的，等号后面直接+整数数字，那么这个变量的数据类型就是int类型，我们叫整型，整型是一个不可变类型

- 在 Python 2.x 中，整数根据保存数值的长度还分为：
  - int（整数）
  - long（长整数）
  - 整型的运算结果只能返回整型，**除法**的结果也不例外。

- 在 Python 3.x 中，整数根据保存数值的长度为：


​		int（整数）

整型数字的最大最小值：

在 32 位系统中，一个整型 4 个字节，最小值 `-2,147,483,648`，最大值 `2,147,483,647`。

在 64 位系统中，一个整型 8 个字节，最小值 `-9,223,372,036,854,775,808`，最大值 `9,223,372,036,854,775,807`。

查看int最大长度

```python
import sys
sys.maxint
```

out:2147483647

### 1.2 浮点型（float）

当我们定一个人的身高的时候，使用height = 1.83 来定义，同理这是float类型，我们叫浮点型，浮点型是一个不可变类型，浮点型直观意义上来讲就是需要把值精确到小数的变量。

```python
3.4 - 3.2
```

out:0.19999999999999973

- 浮点型是不可变类型

- 计算机采用二进制小数来表示浮点数的小数部分

- 部分小数不能用二进制小数完全表示,通常情况下不会影响计算精度

- **Python**的浮点数标准与**C**，**Java**一致，都是[IEEE 754 floating point standard](http://en.wikipedia.org/wiki/IEEE_floating_point)。

  注意看 `3.4 - 3.2` 的结果并不是我们预期的`0.2`，这是因为浮点数本身储存方式引起的，浮点数本身会存在一点误差。

  事实上，**Python** 中储存的值为'0.199999999999999733546474089962430298328399658203125'，因为这是最接近0.2的浮点数。|

可以用`sys.float_info`来查看浮点数的信息：

```python
import sys
sys.float_info
```

### 1.3 布尔型（bool）

- 真 True 非 0 数 —— 非零即真 对应的数字是1
- 假 False 对应的数字是0

### 1.4 复数型 (complex)

主要用于科学计算，例如：平面场问题、波动问题、电感电容等问题

python中使用 `j` 来表示复数的虚部

```python
a = 1 + 2j
type(a)
```

out：complex

## 2. 非数字型

### 2.1 字符串

> [程序练习](https://github.com/Nicolas-gaofeng/Salute_Python/blob/main/code/basic/data_type_python/data_type_string.py)

#### 2.1.1 字符串的定义

- 字符串就是 一串字符，是编程语言中表示文本的数据类型
- 在 Python 中可以使用 一对双引号" 或者 一对单引号 ' 定义一个字符串,大多数编程语言都是用 " 来定义字符串
- Python 用一对 `"""` 或者 `'''` 来生成多行字符串
- 虽然可以使用 \" 或者 \' 做字符串的转义，但是在实际开发中：
  - 如果字符串内部需要使用 "，可以使用 ' 定义字符串
  - 如果字符串内部需要使用 '，可以使用 " 定义字符串
- 可以使用 索引获取一个字符串中 指定位置的字符，索引计数从 0 开始
- 也可以使用 for 循环遍历 字符串中每一个字符

```python
string = "Hello Python"
for c in string:
	print(c)
```

 ![clip_image44002](https://gitee.com/zgf1366/pic_store/raw/master/img/20210120161749.jpg)

#### 2.1.2 字符串的常用操作

**Python**是一种面向对象的语言，面向对象的语言中一个必不可少的元素就是方法，而字符串是对象的一种，所以有很多可用的方法。跟很多语言一样，**Python**使用以下形式来调用方法：

```python
对象.方法(参数)
```

- 在 ipython3 中定义一个 字符串，例如：hello_str = ""
- 输入 hello_str. 按下 TAB 键，ipython 会提示 字符串 能够使用的 方法 如下：

```python
hello_str.
hello_str.capitalize  hello_str.isidentifier hello_str.rindex
hello_str.casefold   hello_str.islower    hello_str.rjust
hello_str.center    hello_str.isnumeric   hello_str.rpartition
hello_str.count     hello_str.isprintable  hello_str.rsplit
hello_str.encode    hello_str.isspace    hello_str.rstrip
hello_str.endswith   hello_str.istitle    hello_str.split
hello_str.expandtabs  hello_str.isupper    hello_str.splitlines
hello_str.find     hello_str.join     hello_str.startswith
hello_str.format    hello_str.ljust     hello_str.strip
hello_str.format_map  hello_str.lower     hello_str.swapcase
hello_str.index     hello_str.lstrip    hello_str.title
hello_str.isalnum    hello_str.maketrans   hello_str.translate
hello_str.isalpha    hello_str.partition   hello_str.upper
hello_str.isdecimal   hello_str.replace    hello_str.zfill
hello_str.isdigit    hello_str.rfind
```

提示：正是因为 python 内置提供的方法足够多，才使得在开发时，能够针对字符串进行更加灵活的操作！应对更多的开发需求！

另外可以使用dir函数查看所有可以使用的方法：

```python
dir(s)
```

##### 2.1.2.1 判断类型

|        方法        |                             说明                             |
| :----------------: | :----------------------------------------------------------: |
|  string.isspace()  |            如果 string 中只包含空格，则返回 True             |
|  string.isalnum()  | 如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True |
|  string.isalpha()  |  如果 string 至少有一个字符并且所有字符都是字母则返回 True   |
| string.isdecimal() |         如果 string 只包含数字则返回 True，全角数字          |
|  string.isdigit()  |    如果 string 只包含数字则返回 True，全角数字、⑴、\u00b2    |
| string.isnumeric() |    如果 string 只包含数字则返回 True，全角数字，汉字数字     |
|  string.istitle()  |   如果 string 是标题化的(每个单词的首字母大写)则返回 True    |
|  string.islower()  | 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True |
|  string.isupper()  | 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回  True |

##### 2.1.2.2 查找和替换

|                          方法                           |                             说明                             |
| :-----------------------------------------------------: | :----------------------------------------------------------: |
|                 string.startswith(str)                  |          检查字符串是否是以 str 开头，是则返回 True          |
|                  string.endswith(str)                   |          检查字符串是否是以 str 结束，是则返回 True          |
|       string.find(str, start=0,  end=len(string))       | 检测 str 是否包含在 string 中，如果 start 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回 -1 |
|       string.rfind(str, start=0, end=len(string))       |             类似于 find()，不过是从右边开始查找              |
|       string.index(str, start=0, end=len(string))       |     跟 find() 方法类似，不过如果 str 不在 string 会报错      |
|      string.rindex(str, start=0, end=len(string))       |               类似于 index()，不过是从右边开始               |
| string.replace(old_str, new_str, num=string.count(old)) | 把 string 中的 old_str 替换成 new_str，如果 num 指定，则替换不超过 num 次 |

##### 2.1.2.3 大小写转换

|        方法         |               说明               |
| :-----------------: | :------------------------------: |
| string.capitalize() |     把字符串的第一个字符大写     |
|   string.title()    |   把字符串的每个单词首字母大写   |
|   string.lower()    | 转换 string 中所有大写字符为小写 |
|   string.upper()    |  转换 string 中的小写字母为大写  |
|  string.swapcase()  |      翻转 string 中的大小写      |

##### 2.1.2.4 文本对齐

|         方法         |                             说明                             |
| :------------------: | :----------------------------------------------------------: |
| string.ljust(width)  | 返回一个原字符串左对齐，并使用空格填充至长度 width 的新字符串 |
| string.rjust(width)  | 返回一个原字符串右对齐，并使用空格填充至长度 width 的新字符串 |
| string.center(width) | 返回一个原字符串居中，并使用空格填充至长度 width 的新字符串  |

##### 2.1.2.5 去除空白字符

|      方法       |                说明                |
| :-------------: | :--------------------------------: |
| string.lstrip() | 截掉 string 左边（开始）的空白字符 |
| string.rstrip() | 截掉 string 右边（末尾）的空白字符 |
| string.strip()  |   截掉 string 左右两边的空白字符   |

##### 2.1.2.6 拆分和连接 

|           方法            |                             说明                             |
| :-----------------------: | :----------------------------------------------------------: |
|   string.partition(str)   | 把字符串 string 分成一个 3 元素的元组 (str前面,  str, str后面) |
|  string.rpartition(str)   |        类似于 partition() 方法，不过是从右边开始查找         |
| string.split(str="", num) | 以 str 为分隔符拆分  string，如果 num 有指定值，则仅分隔 num +  1 个子字符串，str 默认包含 '\r', '\t',  '\n' 和空格 |
|    string.splitlines()    | 按照行('\r', '\n', '\r\n')分隔，返回一个包含各行作为元素的列表 |
|     string.join(seq)      | 以 string 作为分隔符，将 seq 中所有的元素（的字符串表示）合并为一个新的字符串 |

##### 2.1.2.7 使用 `()` 或者 `\` 来换行

当代码太长或者为了美观起见时，我们可以使用两种方法来将一行代码转为多行代码：

*   ()
*   \

```python
a = ("hello, world. "
    "it's a nice day. "
    "my name is xxx")
a
```

Out: "hello, world. it's a nice day. my name is xxx"

```python
a = "hello, world. " \
    "it's a nice day. " \
    "my name is xxx"
a
```

Out:"hello, world. it's a nice day. my name is xxx"

##### 2.1.2.8 强制转换为字符串

*   `str(ob)`强制将`ob`转化成字符串。
*   `repr(ob)`也是强制将`ob`转化成字符串。

不同点如下：

```python
str(1.1 + 2.2)
```

Out:'3.3'

```python
repr(1.1 + 2.2)
```

Out:'3.3000000000000003'

#### 2.1.3 字符串的切片 

- 切片方法适用于 字符串、列表、元组

- - 切片 使用 索引值 来限定范围，从一个大的 字符串 中 切出 小的 字符串
  - 列表 和 元组 都是 有序 的集合，都能够通过索引值 获取到对应的数据
  - 字典 是一个 无序 的集合，是使用 键值对保存数据

字符串[开始索引:结束索引:步长]

**注意**：

a. 指定的区间属于 **左闭右开** 型 [开始索引, 结束索引) => 开始索引 =< 范围 < 结束索引

1. - 从 起始 位开始，到 结束位的前一位结束（不包含结束位本身)

b. 从头开始，开始索引 数字可以省略，冒号不能省略

c. 到末尾结束，结束索引 数字可以省略，冒号不能省略

d. 步长默认为 1，如果连续切片，数字和冒号都可以省略

**索引的顺序和倒序**

- 在 Python 中不仅支持 顺序索引，同时还支持 倒序索引

- 所谓倒序索引就是 从右向左 计算索引

- - 最右边的索引值是 **-1**，依次递减

**字符串中的转义字符**

- \t 在控制台输出一个 制表符，协助在输出文本时垂直方向保持对齐
- \n 在控制台输出一个 换行符

制表符的功能是在不使用表格的情况下在垂直方向按列对齐文本

| 转义字符 |    描述    |
| :------: | :--------: |
|    \\    | 反斜杠符号 |
|    \'    |   单引号   |
|    \"    |   双引号   |
|    \n    |    换行    |
|    \t    | 横向制表符 |
|    \r    |    回车    |

#### 2.1.4 unicode 字符串

- 在 Python 2.x中，即使指定了文件使用 UTF-8 的编码格式，但是在遍历字符串时，仍然会以字节为单位遍历字符串
- 要能够正确的遍历字符串，在定义字符串时，需要在字符串的引号前，增加一个小写字母 `u`，告诉解释器这是一个unicode字符串（使用 UTF-8编码格式的字符串）

```python
# *-* coding:utf8 *-*
# 在字符串前，增加一个 `u` 表示这个字符串是一个 utf8 字符串
hello_str = u"你好世界"
print(hello_str)
for c in hello_str:
    print(c)
```

### 2.2 列表

> [程序练习](https://github.com/Nicolas-gaofeng/Salute_Python/blob/main/code/basic/data_type_python/data_type_list.py)

当我们需要存储一个班级里面所有学生的名字的时候，就是用一个变量来存储多个值，这种情况我们可以只用list这种数据类型来完成，我们叫列表。

#### 2.2.1 列表的定义

- List（列表） 是 Python 中使用 最频繁 的数据类型，在其他语言中通常叫做 数组

- 专门用于存储 一串 信息

- 列表用 [] 定义，数据 之间使用 , 分隔

- 列表的 索引 从 0 开始

- 索引 就是数据在 列表 中的位置编号，索引 又可以被称为 下标

注意：从列表中取值时，如果 超出索引范围，程序会报错

name_list = ["zhangsan", "lisi", "wangwu"]

![clip_image01202](https://gitee.com/zgf1366/pic_store/raw/master/img/20210120162907.jpg)

#### 2.2.2 列表常用操作

- 在 ipython3 中定义一个 列表，例如：name_list = []
- 输入 name_list. 按下 TAB 键，ipython 会提示 列表 能够使用的 方法 如下：

```python
In [1]: name_list.
name_list.append  name_list.count  name_list.insert  name_list.reverse
name_list.clear  name_list.extend  name_list.pop   name_list.sort
name_list.copy   name_list.index  name_list.remove 
```

| 序号* | 分类 |  关键字 / 函数 / 方法   |           说明           |
| :---: | :--: | :---------------------: | :----------------------: |
|   1   | 增加 | 列表.insert(索引, 数据) |    在指定位置插入数据    |
|       |      |    列表.append(数据)    |      在末尾追加数据      |
|       |      |   列表.extend(列表2)    | 将列表2 的数据追加到列表 |
|   2   | 修改 |    列表[索引] = 数据    |    修改指定索引的数据    |
|   3   | 删除 |     del 列表[索引]      |    删除指定索引的数据    |
|       |      |    列表.remove[数据]    | 删除第一个出现的指定数据 |
|       |      |        列表.pop         |       删除末尾数据       |
|       |      |     列表.pop(索引)      |     删除指定索引数据     |
|       |      |       列表.clear        |         清空列表         |
|   4   | 统计 |        len(列表)        |         列表长度         |
|       |      |    列表.count(数据)     |  数据在列表中出现的次数  |
|   5   | 排序 |       列表.sort()       |         升序排序         |
|       |      | 列表.sort(reverse=True) |         降序排序         |
|       |      |     列表.reverse()      |        逆序、反转        |

值的测试

**Python**不仅仅可以使用布尔型变量作为条件，它可以直接在`if`中使用任何表达式作为条件：

大部分表达式的值都会被当作`True`，但以下表达式值会被当作`False`：

*   False
*   None
*   0
*   空字符串，空列表，空字典，空集合

推荐使用 `if len(mylist) > 0:` 来判断一个列表是否为空。

#### 2.2.3 del关键字

- 使用 del 关键字(delete) 同样可以删除列表中元素
- del 关键字本质上是用来 将一个变量从内存中删除的
- 如果使用 del 关键字将变量从内存中删除，后续的代码就不能再使用这个变量了

```python
del name_list[1]
```

在日常开发中，要从列表删除数据，建议 使用列表提供的方法

- 关键字 是 Python 内置的、具有特殊意义的标识符

```python
import keyword
print(keyword.kwlist)
print(len(keyword.kwlist))
```

关键字后面不需要使用括号

#### 2.2.4 循环遍历

- 遍历就是从头到尾依次从列表中获取数据

- - 在循环体内部针对每一个元素，执行相同的操作

- 在 Python 中为了提高列表的遍历效率，专门提供的 迭代 iteration 遍历

- 使用 for 就能够实现迭代遍历

 for 循环内部使用的变量 in 列表

```python
for name in name_list:
  # 循环内部针对列表元素进行操作
	print(name)
```

![clip_image0044](https://gitee.com/zgf1366/pic_store/raw/master/img/20210120162948.jpg)

#### 2.2.5 列表推导式

列表推导式：一行代码几乎搞定你需要的任何的列表。

[expression for value in iterable if condition]

- 三要素：表达式、可迭代对象、if条件（可选）
- 优点：一行解决，方便。
- 缺点：容易着迷，不易排错，不能超过三次循环。

`列表推导式不能解决所有列表的问题`，所以不要太刻意用。

- 执行过程

（1）从可迭代对象中拿出一个元素

（2）通过if条件（如果有的话），对元素进行筛选

- 若通过筛选：则把元素传递给表达式

- 若未通过：则进入（1）步骤，进入下一次迭代

（3）将传递给表达式的元素，代入表达式进行处理，产生一个结果

（4）将（3）步产生的结果作为列表的一个元素进行存储

（5）重复（1）~（4）步，直至迭代对象迭代结束，返回新创建的列表

#### 2.2.6 应用场景

- 尽管 Python 的列表中可以存储不同类型的数据
- 但是在开发中，更多的应用场景是
  - 列表存储相同类型的数据
  - 通过迭代遍历，在循环体内部，针对列表中的每一项元素，执行相同的操作

### 2.3 元组

> [程序练习](https://github.com/Nicolas-gaofeng/Salute_Python/blob/main/code/basic/data_type_python/data_type_tuple.py)

#### 2.3.1 元组的定义

- Tuple（元组）与列表类似，不同之处在于元组的 元素不能修改

  - 元组 表示多个元素组成的序列
  - 元组 在 Python 开发中，有特定的应用场景

- 用于存储 一串 信息，数据 之间使用 , 分隔

- 元组用 () 定义

- 元组的 索引 从 0 开始

  - 索引 就是数据在 元组 中的位置编号

```python
info_tuple = ("zhangsan", 18, 1.75)
```

创建空元组

```python
info_tuple = ()
```

元组中 只包含一个元素 时，需要 在元素后面添加逗号

```python
info_tuple = (50, )
```

![clip_image04502](https://gitee.com/zgf1366/pic_store/raw/master/img/20210120163251.jpg)

#### 2.3.2 元组常用操作

- 在 ipython3 中定义一个 元组，例如：info = ()
- 输入 info. 按下 TAB 键，ipython 会提示 元组 能够使用的函数如下：

```python
info.count info.index
```

#### 2.3.3 循环遍历 

- 取值 就是从 元组 中获取存储在指定位置的数据
- 遍历 就是 从头到尾依次从元组中获取数据

 for 循环内部使用的变量 in 元组

```python
for item in info:
  	# 循环内部针对元组元素进行操作
	print(item)
```

- 在 Python 中，可以使用 for 循环遍历所有非数字型类型的变量：列表、元组、字典以及字符串
- 提示：在实际开发中，除非能够确认元组中的数据类型，否则针对元组的循环遍历需求并不是很多

#### 2.3.4 应用场景

- 尽管可以使用 for in 遍历 元组

- 但是在开发中，更多的应用场景是：

- - 函数的 参数 和 返回值，一个函数可以接收任意多个参数，或者一次返回多个数据
  - 格式字符串，格式化字符串后面的 () 本质上就是一个元组
  - 让列表不可以被修改，以保护数据安全

```python
info = ("zhangsan", 18)
print("%s 的年龄是 %d" % info)
```

#### 2.3.5 元组和列表之间的转换

- 使用 list 函数可以把元组转换成列表

```python
list(元组) 
```

- 使用 tuple 函数可以把列表转换成元组

```python
tuple(列表)
```

#### 2.3.6 不可变集合

对应于元组（`tuple`）与列表（`list`）的关系，对于集合（`set`），**Python**提供了一种叫做不可变集合（`frozen set`）的数据结构。

使用 `frozenset` 来进行创建：

```python
s = frozenset([1, 2, 3, 'a', 1])
s
```

Out: frozenset({1, 2, 3, 'a'})

与集合不同的是，不可变集合一旦创建就不可以改变。

不可变集合的一个主要应用是用来作为字典的键，例如用一个字典来记录两个城市之间的距离：

```python
flight_distance = {}
city_pair = frozenset(['Los Angeles', 'New York'])
flight_distance[city_pair] = 2498
flight_distance[frozenset(['Austin', 'Los Angeles'])] = 1233
flight_distance[frozenset(['Austin', 'New York'])] = 1515
flight_distance
```

Out:{frozenset({'Austin', 'New York'}): 1515,
 frozenset({'Austin', 'Los Angeles'}): 1233,
 frozenset({'Los Angeles', 'New York'}): 2498}

由于集合不分顺序，所以不同顺序不会影响查阅结果：

```python
flight_distance[frozenset(['New York','Austin'])]
```

Out:1515

```python
flight_distance[frozenset(['Austin','New York'])]
```

Out:1515

### 2.4 字典

> [程序练习](https://github.com/Nicolas-gaofeng/Salute_Python/blob/main/code/basic/data_type_python/data_type_dict.py)

#### 2.4.1 字典的定义 

- dictionary（字典）是除列表以外Python 之中最灵活的数据类型

- 字典同样可以用来存储多个数据

  - 通常用于存储描述一个物体的相关信息

- 和列表的区别

  - 列表是有序的对象集合
  - 字典是无序的对象集合（python3.6之后，字典是有序的）

- 字典用 {} 定义,使用 `{}` 或者 `dict()` 来创建一个空的字典

- 字典使用键值对存储数据，键值对之间使用 , 分隔

  - 键 key 是索引
  - 值 value 是数据
  - 键 和 值 之间使用 : 分隔
  - 键必须是唯一的
  - 值可以取任何数据类型，但 键 只能使用 字符串、数字 或 元组

```python
xiaoming = {"name": "小明",
    	     "age": 18,
             "gender": True,
             "height": 1.75}
```

![clip_image0082](https://gitee.com/zgf1366/pic_store/raw/master/img/20210120163427.jpg)

#### 2.4.2 字典的创建/取值过程

字典的底层实现：通过稀疏数组来实现值的存储与访问

**创建：**

第一步：创建一个散列表（稀疏数组 N >> n）第一步：通过hash()计算键的散列值
第二步：根据计算的散列值确定其在散列表中的位置 # 极个别时候，散列值会发生冲突，则内部有相应的解决冲突的办法
第三步：在该位置上存入值

**取值：**
第一步：计算要访问的键的散列值
第二步：根据计算的散列值，通过一定的规则，确定其在散列表中的位置
第三步：读取该位置上存储的值 如果存在，则返回该值 如果不存在，则报错KeyError

#### 2.4.3 字典常用操作 

- 在 ipython3 中定义一个 字典 ，例如：xiaoming = {}
- 输入 xiaoming. 按下 TAB 键，ipython 会提示 字典 能够使用的函数如下：

```python
In [1]: xiaoming.
xiaoming.clear    xiaoming.items    xiaoming.setdefault
xiaoming.copy    xiaoming.keys    xiaoming.update
xiaoming.fromkeys  xiaoming.pop     xiaoming.values
xiaoming.get     xiaoming.popitem  
```

##### 2.4.3.1 get 方法

之前已经见过，用索引可以找到一个键对应的值，但是当字典中没有这个键的时候，Python会报错，这时候可以使用字典的 `get` 方法来处理这种情况，其用法如下：

```python
d.get(key, default = None)`
```

返回字典中键 `key` 对应的值，如果没有这个键，返回 `default` 指定的值（默认是 `None` ）。

##### 2.4.3.2 pop 方法删除元素

`pop` 方法可以用来弹出字典中某个键对应的值，同时也可以指定默认参数：

```python
d.pop(key, default = None)
```

删除并返回字典中键 `key` 对应的值，如果没有这个键，返回 `default` 指定的值（默认是 `None` ）。

##### 2.4.3.3 update 方法更新字典

之前已经知道，可以通过索引来插入、修改单个键值对，但是如果想对多个键值对进行操作，这种方法就显得比较麻烦，好在有 `update` 方法：

```python
d.update(newd)
```

将字典`newd`中的内容更新到`d`中去。

##### 2.4.3.4 in 查询字典中是否有该键

`in` 可以用来判断字典中是否有某个特定的键：

```python
barn = {'cows': 1, 'dogs': 5, 'cats': 3}
'chickens' in barn
```

Out: False

##### 2.4.3.5 keys 方法，values 方法和 items方法

```python
d.keys()
```

返回一个由所有键组成的列表；

```python
d.values()
```

返回一个由所有值组成的列表；

```python
d.items()
```

返回一个由所有键值对元组组成的列表；

##### 2.4.3.6 循环遍历 

-  遍历就是依次从字典中获取所有键值对

for 循环内部使用的 key 的变量 in 字典 

```python
for k in xiaoming:
	print("%s: %s" % (k, xiaoming[k]))
```

提示：在实际开发中，由于字典中每一个键值对保存数据的类型是不同的，所以针对字典的循环遍历需求并不是很多

#### 2.4.4 应用场景

- 尽管可以使用 for in 遍历字典

- 但是在开发中，更多的应用场景是：

- - 使用多个键值对，存储描述一个物体的相关信息 —— 描述更复杂的数据信息
  - 将多个字典放在一个列表中，再进行遍历，在循环体内部针对每一个字典进行相同的处理

```python
card_list = [{"name": "张三",
       		"qq": "12345",
       		"phone": "110"},
       		{"name": "李四",
       		"qq": "54321",
       		"phone": "10086"}
       		]
```

### 2.5 集合

> [程序练习](https://github.com/Nicolas-gaofeng/Salute_Python/blob/main/code/basic/data_type_python/data_type_set.py)

花括号内，多个元素用逗号分割，用来存储多个值，并且是无序的，那么这么多个值不能用来取值，但是我们可以使用它来进行去重(比如去掉列表中重复的元素)和关系运算。

- 集合是可变类型
- 不能重复 没有顺序
- 一系列互不相等元素的无序集合
- 元素必须是不可变类型：数字，字符串或元组，可视作字典的键
- 可以看做是没有值，或者值为None的字典
- 可用于去重

#### 2.5.1 集合生成

可以用`set()`函数来显示的生成空集合：

```python
a = set()
type(a)
```

Out: set

也可以使用一个列表来初始化一个集合：

```python
a = set([1, 2, 3, 1])
a
```

Out:{1, 2, 3}

集合会自动去除重复元素 `1`。

可以看到，集合中的元素是用大括号`{}`包含起来的，这意味着可以用`{}`的形式来创建集合：

```python
a = {1, 2, 3, 1}
a
```

Out:{1, 2, 3}

但是创建空集合的时候只能用`set`来创建，因为在Python中`{}`创建的是一个空的字典：

```python
s = {}
type(s)
```

Out: dict

#### 2.5.2 集合操作

假设有这样两个集合：

```python
a = {1, 2, 3, 4}
b = {3, 4, 5, 6}
```

##### 2.5.2.1 并

两个集合的并，返回包含两个集合所有元素的集合（去除重复）。

可以用方法 `a.union(b)` 或者操作 `a | b` 实现。

```python
a.union(b)
```

Out:{1, 2, 3, 4, 5, 6}

```python
b.union(a)
```

Out:{1, 2, 3, 4, 5, 6}

```python
a | b
```

Out:{1, 2, 3, 4, 5, 6}

##### 2.5.2.2 交

两个集合的交，返回包含两个集合共有元素的集合。

可以用方法 `a.intersection(b)` 或者操作 `a & b` 实现。

```python
a.intersection(b)
```

Out:{3, 4}

```python
b.intersection(a)
```

Out:{3, 4}

```python
a & b
```

Out:{3, 4}

```python
print(a & b)
```

Out: set([3, 4])

注意：一般使用print打印set的结果与表示方法并不一致。

##### 2.5.2.3 差

`a` 和 `b` 的差集，返回只在 `a` 不在 `b` 的元素组成的集合。

可以用方法 `a.difference(b)` 或者操作 `a - b` 实现。

```python
a.difference(b)
```

Out:{1, 2}

```python
a - b
```

Out:{1, 2}

注意，`a - b` 与 `b - a`并不一样，`b - a` 返回的是返回 b 不在 a 的元素组成的集合：

```python
b.difference(a)
```

Out:{5, 6}

```python
b - a 
```

Out:{5, 6}

##### 2.5.2.4 对称差

`a` 和`b` 的对称差集，返回在 `a` 或在 `b` 中，但是不同时在 `a` 和 `b` 中的元素组成的集合。

可以用方法 `a.symmetric_difference(b)` 或者操作 `a ^ b` 实现（异或操作符）。

```python
a.symmetric_difference(b)
```

Out:{1, 2, 5, 6}

```python
b.symmetric_difference(a)
```

Out:{1, 2, 5, 6}

```python
a ^ b
```

Out:{1, 2, 5, 6}

##### 2.5.2.5 包含关系

假设现在有这样两个集合：

```python
a = {1, 2, 3}
b = {1, 2}
```

要判断 `b` 是不是 `a` 的子集，可以用 `b.issubset(a)` 方法，或者更简单的用操作 `b <= a` ：

```python
b.issubset(a)
```

Out:True

```python
b <= a
```

Out:True

与之对应，也可以用 `a.issuperset(b)` 或者 `a >= b` 来判断：

```python
a.issuperset(b)
```

Out:True

```python
a >= b
```

Out:True

方法只能用来测试子集，但是操作符可以用来判断真子集：

```python
a <= a
```

Out:True

自己不是自己的真子集：

```python
a < a
```

Out:False

#### 2.5.3 集合方法

##### 2.5.3.1 add 方法向集合添加单个元素

跟列表的 `append` 方法类似，用来向集合添加单个元素。

```python
s.add(a) 
```

将元素 `a` 加入集合 `s` 中。

```python
t = {1, 2, 3}
t.add(5)
t
```

Out:{1, 2, 3, 5}

如果添加的是已有元素，集合不改变：

```python
t.add(3)
t
```

Out:{1, 2, 3, 5}

##### 2.5.3.2 update 方法向集合添加多个元素

跟列表的`extend`方法类似，用来向集合添加多个元素。

```python
s.update(seq) 
```

将`seq`中的元素添加到`s`中。

```python
t.update([5, 6, 7])
t
```

Out:{1, 2, 3, 5, 6, 7}

##### 2.5.3.3 remove 方法移除单个元素

```python
s.remove(ob) 
```

从集合`s`中移除元素`ob`，如果不存在会报错。

```python
t.remove(1)
t
```

Out:{2, 3, 5, 6, 7}

```python
t.remove(10)
```

```python
---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
<ipython-input-31-3bc25c5e1ff4> in <module>()
----> 1  t.remove(10)

KeyError: 10
```

##### 2.5.3.4 pop方法弹出元素

由于集合没有顺序，不能像列表一样按照位置弹出元素，所以`pop` 方法删除并返回集合中任意一个元素，如果集合中没有元素会报错。

```python
t.pop()
```

Out:{3, 5, 6, 7}

```py
print t
```

Out:set([3, 5, 6, 7])

```python
s = set()
# 报错
s.pop()
```

```python
---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
<ipython-input-34-9f9e06c962e6> in <module>()
 1 s = set()
 2 # 报错
----> 3  s.pop()

KeyError: 'pop from an empty set'
```

##### 2.5.3.5 discard 方法

作用与 `remove` 一样，但是当元素在集合中不存在的时候不会报错。

```python
t.discard(3)
t
```

Out:{5, 6, 7}

不存在的元素不会报错：

```python
t.discard(20)
t
```

Out:{5, 6, 7}

##### 2.5.3.6 difference_update方法

```python
a.difference_update(b) 
```

从a中去除所有属于b的元素

## 3. 容器公共方法

> [程序练习](https://github.com/Nicolas-gaofeng/Salute_Python/blob/main/code/basic/data_type_python/data_type_public_method.py)

### 3.1 Python内置函数

Python 包含了以下内置函数：

|       函数        |               描述                |            备注             |
| :---------------: | :-------------------------------: | :-------------------------: |
|     len(item)     |        计算容器中元素个数         |                             |
|     del(item)     |             删除变量              |       del 有两种方式        |
|     max(item)     |       返回容器中元素最大值        | 如果是字典，只针对 key 比较 |
|     min(item)     |       返回容器中元素最小值        | 如果是字典，只针对 key 比较 |
| cmp(item1, item2) | 比较两个值，-1 小于/0 相等/1 大于 | Python 3.x 取消了 cmp 函数  |

**注意**

- 字符串比较符合以下规则：     "0" < "A" < "a"

### 3.2 切片 

| 描述 |    Python表达式    |  结果   |   支持的数据类型   |
| :--: | :----------------: | :-----: | :----------------: |
| 切片 | "0123456789"[::-2] | "97531" | 字符串、列表、元组 |

- 切片使用索引值来限定范围，从一个大的字符串中切出小的字符串
- 列表和元组都是有序的集合，都能够通过索引值获取到对应的数据
- 字典是一个无序的集合，是使用键值对保存数据

### 3.3 运算符

|    运算符    |     Python表达式      |             结果             |      描述      |      支持的数据类型      |
| :----------: | :-------------------: | :--------------------------: | :------------: | :----------------------: |
|      +       |    [1, 2] + [3, 4]    |         [1, 2, 3, 4]         |      合并      |    字符串、列表、元组    |
|      *       |      ["Hi!"] * 4      | ['Hi!', 'Hi!', 'Hi!', 'Hi!'] |      重复      |    字符串、列表、元组    |
|      in      |    3 in (1, 2, 3)     |             True             |  元素是否存在  | 字符串、列表、元组、字典 |
|    not in    |  4 not in (1, 2, 3)   |             True             | 元素是否不存在 | 字符串、列表、元组、字典 |
| > >= == < <= | (1, 2, 3) < (2, 2, 3) |             True             |    元素比较    |    字符串、列表、元组    |

**注意**

- in 在对 字典 操作时，判断的是 字典的键
- in 和 not in 被称为 成员运算符

**成员运算符**

成员运算符用于测试序列中是否包含指定的成员

| 运算符 |                          描述                          |             实例              |
| :----: | :----------------------------------------------------: | :---------------------------: |
|   in   |   如果在指定的序列中找到值返回 True，否则返回 False    |   3 in (1, 2, 3) 返回 True    |
| not in | 如果在指定的序列中没有找到值返回 True，否则返回  False | 3 not in (1, 2, 3) 返回 False |

注意：在对字典操作时，判断的是字典的键

### 3.4 for 循环语法

- 在 Python 中完整的 for 循环 的语法如下：

```python
for 变量 in 集合:
  # 循环体代码
else:
  # 没有通过break退出循环，循环结束后，会执行的代码
```

### 3.5 应用场景

- 在 迭代遍历嵌套的数据类型时，例如一个列表包含了多个字典

- 需求：要判断某一个字典中是否存在指定的值

  - 如果存在，提示并且退出循环
  - 如果不存在，在循环整体结束后，希望得到一个统一的提示

```python
students = [
        {"name": "阿土", "age": 20, "gender": True, "height": 1.7, "weight": 75.0},
        {"name": "小美", "age": 19, "gender": False, "height": 1.6, "weight": 45.0},
    ]
find_name = "阿土"
for stu_dict in students:
    # 判断当前遍历的字典中姓名是否为find_name
    if stu_dict["name"] == find_name:
        print("找到了")
        # 如果已经找到，直接退出循环，就不需要再对后续的数据进行比较
        break
else:
	print("没有找到")
print("循环结束")
```

### 3.6 可变和不可变类型

1. 不可变类型，内存中的数据不允许被修改：

- 数字类型 int, bool, float, complex, long(2.x)
- 字符串 str
  - 字符串与整数浮点数一样被认为是基本类型，而基本类型在Python中是不可变的
- 元组 tuple

2. 可变类型，内存中的数据可以被修改：

- 列表 list
- 字典 dict

注意：字典的key只能使用不可变类型的数据

**注意**

1. 可变类型的数据变化，是通过方法来实现的

2. 如果给一个可变类型的变量，赋值了一个新的数据，引用会修改

   - 变量不再对之前的数据引用

   - 变量改为对新赋值的数据引用

4. 哈希(hash)

- Python 中内置有一个名字叫做 hash(o) 的函数

  - 接收一个不可变类型的数据作为参数
  - 返回结果是一个整数

- 哈希 是一种算法，其作用就是提取数据的特征码（指纹）

  - 相同的内容得到相同的结果
  - 不同的内容得到不同的结果

- 在 Python 中，设置字典的键值对时，会首先对 key 进行 hash 已决定如何在内存中保存字典的数据，以方便后续对字典的操作：增、删、改、查

  - 键值对的 key 必须是不可变类型数据
  - 键值对的 value 可以是任意类型的数据

## 4. 其他

### 4.1 赋值

对于复制的操作，最简单的就是赋值，指的是新建一个对象的引用，新建目标对象与原来的目标对象指向同一个内存地址，赋值只相当于增加了一个引用，并没有开辟新的内存空间。如下图所示

![image-20210129134432127](https://gitee.com/zgf1366/pic_store/raw/master/img/20210129134432.png)

用 `id` 验证下就知道， list1 和 list2 仍然是同一个东西 。那么他们内部的元素自然也是一样的，对其中一个进行修改，另一个也会跟着变：

```python
list1 = [1, 2, [3, 4], [5, [6, 7]]]
print('list1:', id(list1))
print([id(i) for i in list1])
list2 = list1
print('list2:', id(list2))
print([id(i) for i in list2])
print(list1 is list2)
print(list1[0] is list2[0])
print(list1[2] is list2[2])
list2[0] = -1
print(list1)
list2[2][1] = -1
print(list1)
```

因此有人将此操作称为“ 旧瓶装旧酒 ”，只是多贴了一层标签，这不能达到我们的目的。要得到一个对象的“拷贝”，我们需要用到 `copy` 方法。

### 4.2 深浅拷贝

> [程序练习](https://github.com/Nicolas-gaofeng/Salute_Python/blob/main/code/basic/data_type_python/data_copy.py)

列表内的元素可以分散的存储在内存中

列表存储的，实际上是这些元素的地址！！！——地址的存储在内存中是连续的

#### 4.2.1 浅拷贝

浅拷贝顾名思义就是拷贝的比较浅，我们可以把赋值认为是新建了一个对象的引用，把原来被对象内存空间的数据指向新的变量，这时同一块内存空间指向两个变量。浅拷贝与赋值不同，既然是拷贝，那么就是要开辟一块新的内存空间，复制的是原来被拷贝对象内多个元素对象的引用，有几个元素对象就赋值几个元素对象的引用，也有人把这种操作称为“新瓶装旧酒”。不过，如果旧的酒瓶里面如果还套了一个酒瓶子，那你就需要注意了。因此，不论是对拷贝对象或者是被拷贝对象内**一个可变类型元素内的元素**的修改（包含添加，修改和删除），都会引起另外一方的变化。但是，如果是直接对对象内的一级元素当作**一个整体进行修改**（这时对可变类型元素的元素只能是删除），虽然他们的元素有共享的内存地址，但是拷贝对象或者被拷贝对象元素内的引用都是独立的，删除了其中一方的一个引用，另外一方的引用依然存在。

![image-20210129134546926](https://gitee.com/zgf1366/pic_store/raw/master/img/20210129134547.png)

- 浅拷贝是对于一个对象的顶层拷贝
- 对于浅拷贝来说，第一层在内存中是独立的，从第二层开始以及更深的层数，都是使用的一个内存地址，一变都变
- 切片属于浅copy

通俗的理解是：拷贝了引用，并没有拷贝内容

**注意**

浅拷贝对不可变类型和可变类型的copy不同

1. copy.copy对于可变类型，会进行浅拷贝
2. copy.copy对于不可变类型，不会拷贝，仅仅是指向
   原因：因为不可变类型意味着数据一定不能修改，因此用copy.copy的
   时候它会自动判断，如果是不可变类型就是指向了它
3. 如果用copy.copy、copy.deepcopy对全部都是不可变类型的数据进行拷贝，那么它们结果相同，都是引用指向
4. 如果拷贝的是一个拥有不可变类型的数据，即使元组是最顶层，那么deepcopy依然是深拷贝而copy.copy还是指向

#### 4.2.2 深拷贝

深拷贝其实与浅拷贝有本质的区别，它不会复制任何的引用，对象内的所有元素，子元素，孙子元素，重孙元素，曾孙元素的数据都是由复制而来，因此，这样的操作被称为“新瓶装新酒”。它的实现原理就是递归，只要任意元素内仍然有子元素，就会复制子元素的数据放到新的内存地址。既然这样，在使用深拷贝后，被拷贝对象的改变，不会引起拷贝对象的任何改变。

- 深拷贝是对于一个对象所有层次的拷贝(递归)

#### 4.2.3 拷贝的其他方式

- 分片表达式可以赋值一个序列

- 字典的copy方法可以拷贝一个字典

### 4.3 collections容器数据类型

#### 4.3.1 namedtuple 命名元组

```python
from collections import namedtuple # 从collections库中导入namedtuple（导入外部库）
# 创建一个命名元组对象
point = namedtuple('p', ['x', 'y'])  # p代表名称，"x"和"y"为内容
p = point(1, 2)
print(p)
print(p.x)  # 1
print(p.y)  # 2
```

#### 4.3.2 deque 超级列表

数据结构中比较常用的双向队列在python中可使用deque实现。

```python
from collections import deque
# 类似列表(list)的容器，实现了在两端快速添加(append)和弹出(pop)
d = deque('abcd')
for i in d:
    print(i)
print(d[0])
print(d[1])
d.append('e')  # 从右边加入
print(d)
d.appendleft('x')  # 从左边加入
print(d)
d.pop()  # 从右侧弹出
print(d)
d.popleft()  # 从左侧弹出
print(d)
deque(reversed(d))  # 反转顺序
print(d)
# d = list(d)  # 转化成list
# d = list(reversed(d))
# print(d)
d.extend('xyz')  # 从右侧添加
print(d)
d.extendleft('nba')  # 从左侧添加
print(d)
d.rotate(1)  # 把最右边的元素挪到最左边
print(d)
d.rotate(-1)  # 把最左边的元素挪到最右边
print(d)
d.clear()  # 清空
# d.pop()  # 报错
```

#### 4.3.3 ChainMap 链映射

```python
from collections import ChainMap
"""
一个 ChainMap 类是为了将多个映射快速的链接到一起，这样它们就可以作为一个单元处理。
它通常比创建一个新字典和多次调用 update() 要快很多。
这个类可以用于模拟嵌套作用域，并且在模版化的时候比较有用。
"""
# 链映射的用法
dict1 = {'name': 'Albert', 'age': 18}
dict2 = {'weight': 65, 'height': 180}
res = list(ChainMap(dict1, dict2))
print(res)
```

#### 4.3.4 Counter 计数字典

```python
from collections import Counter
# 计数
cnt = Counter()
for word in ['red', 'blue', 'red', 'green', 'blue', 'blue']:
    cnt[word] += 1# 对word的计数数量加
print(cnt)
# Counter({'blue': 3, 'red': 2, 'green': 1})
# 数学运算
c = Counter(a=3, b=1)
d = Counter(a=1, b=2)
print(c + d)  # 相同的部分相加
# Counter({'a': 4, 'b': 3})
print(c - d)  # 相同的部分相减
# Counter({'a': 2})
print(c & d)  # 相同的部分取最小
# Counter({'a': 1, 'b': 1})
print(c | d)  # 相同的部分取最大
# Counter({'a': 3, 'b': 2})
```

#### 4.3.5 OrderedDict 

#### 4.3.6 defaultdict 

#### 4.3.7 UserDict

#### 4.3.8 UserList

#### 4.3.9 UserString

他们的用法不是完全相同，但是使用起来并不复杂，更多Collections容器类型数据结构详见官方文档：[Collections容器数据类型](https://link.zhihu.com/?target=https%3A//docs.python.org/zh-cn/3/library/collections.html)。

### 4.4 可迭代对象

> [程序练习](https://github.com/Nicolas-gaofeng/Salute_Python/blob/main/code/basic/data_type_python/python_iterator_o.py)

可迭代对象包括：

1. 迭代器 （包括生成器）。
2. 字符串 str，列表 list， 字典 dict，元组 tuple，集合 set。
3. 实现了 __iter__ 方法的对象。

#### 4.4.1 判断一个变量是否可以迭代

```python
from collections import Iterable
isinstance(变量, Iterable)
# example
isinstance([], Iterable)
Out[51]: True
isinstance({}, Iterable)
Out[52]: True
isinstance('abc', Iterable)
Out[53]: True
isinstance(mylist, Iterable)
Out[54]: False
isinstance(100, Iterable)
Out[55]: False
```

#### 4.4.2 可迭代对象的本质

我们分析对可迭代对象进行迭代使用的过程，发现每迭代一次（即在for...in...中每循环一次）都会返回对象中的下一条数据，一直向后读取数据直到迭代了所有数据后结束。那么，在这个过程中就应该有一个“人”去记录每次访问到了第几条数据，以便每次迭代都可以返回下一条数据。我们把这个能帮助我们进行数据迭代的“人”称为**迭代器(Iterator)**。

可迭代对象的本质就是可以向我们提供一个这样的中间“人”即迭代器帮助我们对其进行迭代遍历使用。

可迭代对象通过`__iter__`方法向我们提供一个迭代器，我们在迭代一个可迭代对象的时候，实际上就是先获取该对象提供的一个迭代器，然后通过这个迭代器来依次获取对象中的每一个数据.

那么也就是说，一个具备了`__iter__`方法的对象，就是一个可迭代对象。

```python
class MyList(object):
	def __init__(self):
		self.container = []
	def add(self, item):
		self.container.append(item)
	def __iter__(self):
        """返回一个迭代器"""
        # 我们暂时忽略如何构造一个迭代器对象
        pass

mylist = MyList()
from collections import Iterable
isinstance(mylist, Iterable)
True
# 这回测试发现添加了__iter__方法的mylist对象已经是一个可迭代对象了
```

#### 4.4.3 iter()函数与next()函数

list、tuple等都是可迭代对象，我们可以通过iter()函数获取这些可迭代对象的迭代器。然后我们可以对获取到的迭代器不断使用next()函数来获取下一条数据。iter()函数实际上就是调用了可迭代对象的`__iter__`方法。

```python
li = [11, 22, 33, 44, 55]
li_iter = iter(li)
next(li_iter)
11
next(li_iter)
22
next(li_iter)
33
next(li_iter)
44
next(li_iter)
55
next(li_iter)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
>>>
```

注意，当我们已经迭代完最后一个数据之后，再次调用next()函数会抛出StopIteration的异常，来告诉我们所有数据都已迭代完成，不用再执行next()函数了。

### 4.5 迭代器

> [程序练习](https://github.com/Nicolas-gaofeng/Salute_Python/blob/main/code/basic/data_type_python/python_iterator.py)

迭代就是循环。迭代器是一个可以记住遍历的位置的对象。

迭代器可以通过 next() 方法不断重复获取下一个值，直到所有元素全部输出完之后，返回 StopIteration才停止。同时实现在 `__iter__` 和 `__next__` 两个函数的对象，就是迭代器。其中 `__iter__` 方法需要返回一个迭代器, 而 `__next__` 方法返回下一个返回值或者StopIteration。

迭代器只能往后迭代，不能回退（执行 `__next__` 方法只能向后，不能向前）

它与列表的区别在于，构建迭代器的时候，不像列表把所有元素一次性加载到内存，而是以一种延迟计算（lazy evaluation）方式返回元素，这正是它的优点。比如列表含有中一千万个整数，需要占超过400M的内存，而迭代器只需要几十个字节的空间。因为它并没有把所有元素装载到内存中，而是等到调用 next 方法时候才返回该元素（按需调用 call by need 的方式，本质上 for 循环就是不断地调用迭代器的next方法）。

迭代器有两个基本的方法：iter() 和 next()。

#### 4.5.1 创建迭代器

字符串，列表或元组对象都可用于创建迭代器：

```python
list=[1,2,3,4]
it = iter(list)  # 创建迭代器对象
print(next(it)) # 输出迭代器的下一个元素
1
print(next(it))
2
```

把一个类作为一个迭代器使用需要在类中实现两个方法 `__iter__()` 与 `__next__()` 。

如果你已经了解的面向对象编程，就知道类都有一个构造函数，Python 的构造函数为 `__init__()`, 它会在对象初始化的时候执行。

`__iter__()` 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 `__next__()` 方法并通过 StopIteration 异常标识迭代的完成。

`__next__()` 方法（Python 2 里是 next()）会返回下一个迭代器对象。

创建一个返回数字的迭代器，初始值为 1，逐步递增 1：

```python
class MyNumbers:
  def __iter__(self):
    self.a = 1
    return self
 
  def __next__(self):
    x = self.a
    self.a += 1
    return x
 
myclass = MyNumbers()
myiter = iter(myclass)
print(next(myiter))
print(next(myiter))
print(next(myiter))
print(next(myiter))
print(next(myiter))
```

#### 4.5.2 迭代器取值

迭代器对象可以使用常规for语句进行遍历：

```python
list=[1,2,3,4]
it = iter(list)    # 创建迭代器对象
for x in it:
    print (x, end=" ")
```

也可以使用 next() 函数：

```python
import sys         
list=[1,2,3,4]
it = iter(list)    # 创建迭代器对象
while True:
    try:
        print (next(it))
    except StopIteration:
        sys.exit()
```

#### 4.5.3 判断是否为迭代器

```python
from collections import Iterator
isinstance(变量, Iterator)
```

#### 4.5.4 StopIteration

StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况，在 `__next__()` 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。

```python
class MyNumbers:
  def __iter__(self):
    self.a = 1
    return self
 
  def __next__(self):
    if self.a <= 20:
      x = self.a
      self.a += 1
      return x
    else:
      raise StopIteration
 
myclass = MyNumbers()
myiter = iter(myclass)
 
for x in myiter:
  print(x)
```

#### 4.5.5 并不是只有for循环能接收可迭代对象

除了for循环能接收可迭代对象，list、tuple等也能接收。

```python
li = list(FibIterator(15))
print(li)
tp = tuple(FibIterator(6))
print(tp)
```

### 4.6 生成器

> [程序练习](https://github.com/Nicolas-gaofeng/Salute_Python/blob/main/code/basic/data_type_python/python_generator.py)

#### 4.6.1 什么是生成器

首先有个需求，将列表 [0，1，2，3，4，5，6，7，8，9]里面的每个值加1，你怎么实现呢？

方法一（简单）：

```python
info = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
b = []
# for index,i in enumerate(info):
#     print(i+1)
#     b.append(i+1)
# print(b)
for index,i in enumerate(info):
    info[index] +=1
print(info)
```

方法二（一般）：

```python
info = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
a = map(lambda x:x+1,info)
print(a)
for i in a:
    print(i)
```

方法三（高级）：

```python
info = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
a = [i+1 for i in range(10)]
print(a)
```

通过列表生成式，我们可以直接创建一个列表，但是，受到内存限制，列表容量肯定是有限的，而且创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。

所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间，在Python中，这种一边循环一边计算的机制，称为生成器：generator

生成器是一个特殊的程序，可以被用作控制循环的迭代行为，python中生成器是迭代器的一种，使用yield返回值函数，每次调用yield会暂停，而可以使用next()函数和send()函数恢复生成器。

生成器类似于返回值为数组的一个函数，这个函数可以接受参数，可以被调用，但是，不同于一般的函数会一次性返回包括了所有数值的数组，生成器一次只能产生一个值，这样消耗的内存数量将大大减小，而且允许调用函数可以很快的处理前几个返回值，因此生成器看起来像是一个函数，但是表现得却像是迭代器

#### 4.6.2 python中的生成器

生成器是一种特殊的迭代器，不过实现更加简单。要创建一个generator，有很多种方法

##### 4.6.2.1 生成器表达式

第一种方法很简单，只有把一个列表生成式的[]中括号改为（）小括号，就创建一个generator

生成器表达式：返回一个对象，这个对象只有在需要的时候才产生结果

生成器表达式来源于迭代和列表解析的组合，生成器和列表解析类似，但是它使用尖括号而不是方括号

```python
#列表生成式
lis = [x*x for x in range(10)]
print(lis)
#生成器
generator_ex = (x*x for x in range(10))
print(generator_ex)
结果：
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
<generator object <genexpr> at 0x000002A4CBF9EBA0>
```

 那么创建list和generator_ex，的区别是什么呢？从表面看就是[]和（）,但是结果却不一样，一个打印出来是列表（因为是列表生成式），而第二个打印出来却是<generator object <genexpr> at 0x000002A4CBF9EBA0>，那么如何打印出来generator_ex的每一个元素呢？如果要一个个打印出来，可以通过next（）函数获得generator的下一个返回值：

```python
#生成器
generator_ex = (x*x for x in range(3))
print(next(generator_ex)) # 0
print(next(generator_ex)) # 1
print(next(generator_ex)) # 4
print(next(generator_ex)) # 
Traceback (most recent call last):
  File "列表生成式.py", line 42, in <module>
    print(next(generator_ex))
StopIteration
```

可以看到，generator保存的是算法，每次调用next(generaotr_ex)就计算出他的下一个元素的值，直到计算出最后一个元素，没有更多的元素时，抛出StopIteration的错误，而且上面这样不断调用是一个不好的习惯，正确的方法是使用for循环，因为generator也是可迭代对象：

```python
#生成器
generator_ex = (x*x for x in range(3))
for i in generator_ex:
    print(i)
结果：
0
1
4
```

所以我们创建一个generator后，基本上永远不会调用next()，而是通过for循环来迭代，并且不需要关心StopIteration的错误，generator非常强大，如果推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现。

##### 4.6.2.2 生成器函数

生成器函数：也是用def定义的，利用关键字yield一次性返回一个结果，阻塞，重新开始

为什么叫生成器函数？因为它随着时间的推移生成了一个数值队列。一般的函数在执行完毕之后会返回一个值然后退出，但是生成器函数会自动挂起，然后重新拾起急需执行，他会利用yield关键字关起函数，给调用者返回一个值，同时保留了当前的足够多的状态，可以使函数继续执行，生成器和迭代协议是密切相关的，迭代器都有一个__next__()成员方法，这个方法要么返回迭代的下一项，要么引起异常结束迭代。

比如著名的斐波那契数列，除第一个和第二个数外，任何一个数都可以由前两个相加得到：

1，1，2，3，5，8，12，21，34.....

斐波那契数列用列表生成式写不出来，但是，用函数把它打印出来却很容易：

```python
#fibonacci数列
def fib(max):
    n,a,b =0,0,1
    while n < max:
        a,b =b,a+b
        n = n+1
        print(a)
    return 'done'
 
a = fib(10)
print(fib(10))
```

a,b = b ,a+b 其实相当于 t =a+b ,a =b ,b =t ，所以不必写显示写出临时变量t，就可以输出斐波那契数列的前N个数字。

仔细观察，可以看出，`fib`函数实际上是定义了斐波拉契数列的推算规则，可以从第一个元素开始，推算出后续任意的元素，这种逻辑其实非常类似generator。也就是说上面的函数也可以用generator来实现，上面我们发现，print(b)每次函数运行都要打印，占内存，所以为了不占内存，我们也可以使用生成器，这里叫yield。如下：

```python
def fib(max):
    n,a,b =0,0,1
    while n < max:
        yield b
        a,b =b,a+b
        n = n+1
    return 'done'
 
a = fib(10)
print(fib(10))
```

但是返回的不再是一个值，而是一个生成器，和上面的例子一样，大家可以看一下结果：

```python
<generator object fib at 0x000001C03AC34FC0>
```

那么这样就不占内存了，这里说一下generator和函数的执行流程，函数是顺序执行的，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次被next（）调用时候从上次的返回yield语句处急需执行，也就是用多少，取多少，不占内存。

```python
def fib(max):
    n,a,b =0,0,1
    while n < max:
        yield b
        a,b =b,a+b
        n = n+1
    return 'done'
 
a = fib(10)
print(fib(10))
print(a.__next__())
print(a.__next__())
print(a.__next__())
print("可以顺便干其他事情")
print(a.__next__())
print(a.__next__())
 
结果：
<generator object fib at 0x0000023A21A34FC0>
1
1
2
可以顺便干其他事情
3
5
```

在上面fib的例子，我们在循环过程中不断调用`yield`，就会不断中断。当然要给循环设置一个条件来退出循环，不然就会产生一个无限数列出来。同样的，把函数改成generator后，我们基本上从来不会用`next()`来获取下一个返回值，而是直接使用`for`循环来迭代：

```python
def fib(max):
    n,a,b =0,0,1
    while n < max:
        yield b
        a,b =b,a+b
        n = n+1
    return 'done'
for i in fib(6):
    print(i)
     
结果：
1
1
2
3
5
8
```

但是用for循环调用generator时，发现拿不到generator的return语句的返回值。如果拿不到返回值，那么就会报错，所以为了不让报错，就要进行异常处理，拿到返回值，如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中：

```python
def fib(max):
    n,a,b =0,0,1
    while n < max:
        yield b
        a,b =b,a+b
        n = n+1
    return 'done'
g = fib(6)
while True:
    try:
        x = next(g)
        print('generator: ',x)
    except StopIteration as e:
        print("生成器返回值：",e.value)
        break
结果：
generator:  1
generator:  1
generator:  2
generator:  3
generator:  5
generator:  8
生成器返回值： done
```

##### 4.6.2.3 yield表达式

yield可以把函数暂停住，那么自然就能保存函数的运行状态，我们可以使用yield表达式形式来做一些有意思的操作。

```python
def eat(name):
    print('【1】%s is ready for eating' % name)
    while True:
        food = yield  # 这是yield表达式形式，yield可以赋值给一个变量
        print('【2】%s starts to eat %s' % (name, food))


person1 = eat('Albert')

# 函数暂停在food = yield这行代码
person1.__next__()

# 继续执行代码，由于yield没有值，即yield = None，则food = None
person1.__next__()
```

yield肯定不能一直为空，肯定有一种方法给yield传值，这种方法就是send。

```python
def eat(name):
    print('【1】%s is ready for eating' % name)
    while True:
        food = yield
        print('【2】%s starts to eat %s' % (name, food))


person1 = eat('Albert')
"""
对于表达式形式的yield，在使用前必先初始化
即第一次必须传None，或者用__next__方法
"""
# person1.send(None)  # 初始化，和下面一行代码同等效果
person1.__next__()

person1.send('蒸羊羔')  # send有两个功能：1 传值，2 初始化
person1.send('蒸鹿茸')
person1.send('蒸熊掌')
person1.send('烧素鸭')
person1.close()  # 关闭之后，后面的就吃不了了，也不能兜着走
# person1.send('烧素鹅')
# person1.send('烧鹿尾')
```

我们原本就知道yield可以有返回值，那么能否与yield表达式形式连用呢？如果我们需要记录吃过的东西，就要用到这种用法。

```python
def eat(name):
    print('%s is ready for eating' % name)
    food_list = []
    while True:
        food = yield food_list
        print('%s starts to eat %s' % (name, food))
        food_list.append(food)


name = 'Albert'

person1 = eat(name)

person1.send(None)
# person1.__next__()

res1 = person1.send('蒸羊羔')
print('%s has eaten %s' % (name, res1))

res2 = person1.send('蒸鹿茸')
print('%s has eaten %s' % (name, res2))

res3 = person1.send('蒸熊掌')
print('%s has eaten %s' % (name, res3))

res4 = person1.send('烧素鸭')
print('%s has eaten %s' % (name, res4))

person1.close()  # 关闭之后，后面的就吃不了了，也不能兜着走
# person1.send('烧素鹅')
# person1.send('烧鹿尾')
```

以上这种写法能够帮助你更好的理解yield的执行过程，但是明显有点啰嗦，为了实现同样的功能，我们还有更加简介的写法。

```python
def eat(name):
    print('%s is ready for eating' % name)
    food_list = []
    while True:
        food = yield food_list
        print('%s starts to eat %s' % (name, food))
        food_list.append(food)
        print('%s has eaten %s' % (name, food_list))


person1 = eat('Albert')

person1.send(None)

person1.send('蒸羊羔')

person1.send('蒸鹿茸')

person1.send('蒸熊掌')

person1.send('烧素鸭')

person1.close()
```

##### 4.6.2.4 使用send唤醒 

我们除了可以使用next()函数来唤醒生成器继续执行外，还可以使用send()函数来唤醒执行。使用send()函数的一个好处是可以在唤醒的同时向断点处传入一个附加数据。

例子：执行到yield时，gen函数作用暂时保存，返回i的值; temp接收下次c.send("python")，send发送过来的值，c.next()等价c.send(None)

```python
In [10]: def gen():
   ....:     i = 0
   ....:     while i<5:
   ....:         temp = yield i
   ....:         print(temp)
   ....:         i+=1
   ....:
```

使用send

```python
In [43]: f = gen()

In [44]: next(f)
Out[44]: 0

In [45]: f.send('haha')
haha
Out[45]: 1

In [46]: next(f)
None
Out[46]: 2

In [47]: f.send('haha')
haha
Out[47]: 3

In [48]:
```

使用next函数

```python
In [11]: f = gen()

In [12]: next(f)
Out[12]: 0

In [13]: next(f)
None
Out[13]: 1

In [14]: next(f)
None
Out[14]: 2

In [15]: next(f)
None
Out[15]: 3

In [16]: next(f)
None
Out[16]: 4

In [17]: next(f)
None
---------------------------------------------------------------------------
StopIteration                             Traceback (most recent call last)
<ipython-input-17-468f0afdf1b9> in <module>()
----> 1 next(f)

StopIteration:
```

使用`__next__()`方法（不常使用）

```python
In [18]: f = gen()

In [19]: f.__next__()
Out[19]: 0

In [20]: f.__next__()
None
Out[20]: 1

In [21]: f.__next__()
None
Out[21]: 2

In [22]: f.__next__()
None
Out[22]: 3

In [23]: f.__next__()
None
Out[23]: 4

In [24]: f.__next__()
None
---------------------------------------------------------------------------
StopIteration                             Traceback (most recent call last)
<ipython-input-24-39ec527346a9> in <module>()
----> 1 f.__next__()

StopIteration:
```

##### 4.6.2.5生成器函数 vs 迭代器

- 内存级别的区别。
  - 迭代器是需要可迭代对象进行转化。可迭代对象非常占内存。
  - 生成器直接创建，不需要转化，从本质就节省内存。
- 迭代器不一定是生成器，生成器一定是迭代器
- 凡是可作用于 for 循环的对象都是 Iterable 类型； 凡是可作用于 next() 函数的对象都是 Iterator 类型
- 集合数据类型如 list 、 dict 、 str 等是 Iterable 但不是 Iterator ，不过可以通过 iter() 函数获得一个Iterator 对象。

#### 4.6.3 总结

- 使用了yield关键字的函数不再是函数，而是生成器。（使用了yield的函数就是生成器）
- yield关键字有两点作用：
  - 保存当前运行状态（断点），然后暂停执行，即将生成器（函数）挂起
  - 将yield关键字后面表达式的值作为返回值返回，此时可以理解为起到了return的作用
- 可以使用next()函数让生成器从断点处继续执行，即唤醒生成器（函数）
- Python3中的生成器可以使用return返回最终运行的返回值，而Python2中的生成器不允许使用return返回一个返回值（即可以使用return从生成器中退出，但return后不能有任何表达式）。